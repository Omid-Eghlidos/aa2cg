#include "outputs.h"
#include <iostream>


using Eigen::MatrixXd;


// Mapping scheme method
namespace MappingScheme {

    // Constructor fo mapping scheme method
    Outputs::Outputs(const Inputs &inputs, const LMP_data &data, const LMP_dump &dump,
                     const CG_data &cg_data, const CG_dump &cg_dump) :
                     _inputs(inputs), _data(data), _dump(dump), _cg_data(cg_data),
                     _cg_dump(cg_dump) {
        fmt::print("\n################ Writing the outputs ####################\n");
        _write_cg_data();
        _write_cg_dump();
    }


    void Outputs::_write_cg_data() const {
        std::string path = _inputs.tag + ".lammps";
        std::fstream fid(path, std::fstream::out);
        // System properties
        fmt::print(fid, "LAMMPS data file generated by aa2cg.\n\n");
        fmt::print(fid, "{} atoms\n{} atom types\n"
                      , _cg_data.beads.size(), _cg_data.bead_types.size());
        // Bonds
        int num_bonds = 0;
        for (size_t i=0; i<_cg_data.bead_bonds.size(); i++) {
            for (size_t j=0; j<_cg_data.bead_bonds[i].size(); j++) {
                if ((int)i < _cg_data.bead_bonds[i][j]) {
                    num_bonds++;
                }
            }
        }
        fmt::print(fid, "{} bonds\n{} bond types\n"
                      , num_bonds, _cg_data.bead_bond_types.size());
        fmt::print(fid, "{} angles\n{} angle types\n"
                      , _cg_data.bead_angles.size(), _cg_data.bead_angle_types.size());
        fmt::print(fid, "{} dihedrals\n{} dihedral types\n"
                      , _cg_data.bead_torsions.size(), _cg_data.bead_torsion_types.size());
        if (_cg_data.bead_impropers.size() > 0) {
            fmt::print(fid, "{} impropers\n{} improper types\n"
                      , _cg_data.bead_impropers.size(), _cg_data.bead_improper_types.size());
        }
        fmt::print(fid, "\n");
        // Simulation box boundaries in x, y, and z direction
        auto xy = _data.box(0,1);
        auto xz = _data.box(0,2);
        auto yz = _data.box(1,2);
        auto xlo = 0.0;
        auto xhi = _data.box(0,0);
        auto ylo = 0.0;
        auto yhi = _data.box(1,1);
        auto zlo = 0.0;
        auto zhi = _data.box(2,2);
        // For data file contrary to the dump file the triclinic boundaries
        // themselves are written and not the bounding orthogonal box
        // https://docs.lammps.org/read_data.html
        fmt::print(fid, "{:6.3f} {:6.3f} xlo xhi\n", xlo, xhi);
        fmt::print(fid, "{:6.3f} {:6.3f} ylo yhi\n", ylo, yhi);
        fmt::print(fid, "{:6.3f} {:6.3f} zlo zhi\n", zlo, zhi);
        if (xy != 0.0 || xz != 0.0 || yz != 0.0) {
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f} xy xz yz\n", xy, xz, yz);
        }
        fmt::print(fid, "\n");
        // Masses
        fmt::print(fid, "Masses\n\n");
        for (auto const& [type, mass] : _cg_data.bead_types_masses) {
            fmt::print(fid, "{} {:6.3f}\n", type+1, mass);
        }
        if (_inputs.atom_style == "full") {
            // Atoms
            fmt::print(fid, "\nAtoms # full\n\n");
            for (size_t i=0; i<_cg_data.beads.size(); i++) {
                auto bead = _cg_data.beads[i];
                fmt::print(fid, "{} {} {} {:6.3f} "
                              , bead.id+1, bead.chain+1, bead.type+1, bead.charge);
                for (int k=0; k<bead.coords.rows(); k++) {
                    fmt::print(fid, "{:6.3f} ", bead.coords(k));
                }
                fmt::print(fid, "\n");
            }
        }
        else if (_inputs.atom_style == "molecular") {
            // Atoms
            fmt::print(fid, "\nAtoms # molecular\n\n");
            for (size_t i=0; i<_cg_data.beads.size(); i++) {
                auto bead = _cg_data.beads[i];
                fmt::print(fid, "{} {} {} ", bead.id+1, bead.chain+1, bead.type+1);
                for (int k=0; k<bead.coords.rows(); k++) {
                    fmt::print(fid, "{:6.3f} ", bead.coords(k));
                }
                fmt::print(fid, "\n");
            }
        }
        // Bonds
        fmt::print(fid, "\nBonds\n\n");
        int bond_id = 0;
        for (size_t i=0; i<_cg_data.bead_bonds.size(); i++) {
            for (size_t j=0; j<_cg_data.bead_bonds[i].size(); j++) {
                if ((int)i < _cg_data.bead_bonds[i][j]) {
                    bond_id++;
                    fmt::print(fid, "{} {} {} {}\n", bond_id
                                  , _cg_data.get_bond_type(i, _cg_data.bead_bonds[i][j]) + 1
                                  , i + 1, _cg_data.bead_bonds[i][j] + 1);
                }
            }
        }
        // Angles
        fmt::print(fid, "\nAngles\n\n");
        for (size_t i=0; i<_cg_data.bead_angles.size(); i++) {
            fmt::print(fid, "{} {} {} {} {}\n"
                          , i + 1
                          , _cg_data.get_angle_type(std::get<0>(_cg_data.bead_angles[i])
                                              , std::get<1>(_cg_data.bead_angles[i])
                                              , std::get<2>(_cg_data.bead_angles[i]))
                          , std::get<0>(_cg_data.bead_angles[i]) + 1
                          , std::get<1>(_cg_data.bead_angles[i]) + 1
                          , std::get<2>(_cg_data.bead_angles[i]) + 1);
        }
        // Dihedrals
        fmt::print(fid, "\nDihedrals\n\n");
        for (size_t i=0; i<_cg_data.bead_torsions.size(); i++) {
            fmt::print(fid, "{} {} {} {} {} {}\n"
                          , i + 1
                          , _cg_data.get_torsion_type(std::get<0>(_cg_data.bead_torsions[i])
                                                , std::get<1>(_cg_data.bead_torsions[i])
                                                , std::get<2>(_cg_data.bead_torsions[i])
                                                , std::get<3>(_cg_data.bead_torsions[i]))
                          , std::get<0>(_cg_data.bead_torsions[i]) + 1
                          , std::get<1>(_cg_data.bead_torsions[i]) + 1
                          , std::get<2>(_cg_data.bead_torsions[i]) + 1
                          , std::get<3>(_cg_data.bead_torsions[i]) + 1);
        }
        // Impropers
        if (_cg_data.bead_impropers.size() > 0){
            fmt::print(fid, "\nImpropers\n\n");
            for (size_t i=0; i<_cg_data.bead_impropers.size(); i++) {
                fmt::print(fid, "{} {} {} {} {} {}\n" , i + 1
                         , _cg_data.get_improper_type(std::get<0>(_cg_data.bead_impropers[i])
                                                    , std::get<1>(_cg_data.bead_impropers[i])
                                                    , std::get<2>(_cg_data.bead_impropers[i])
                                                    , std::get<3>(_cg_data.bead_impropers[i]))
                              , std::get<0>(_cg_data.bead_impropers[i]) + 1
                              , std::get<1>(_cg_data.bead_impropers[i]) + 1
                              , std::get<2>(_cg_data.bead_impropers[i]) + 1
                              , std::get<3>(_cg_data.bead_impropers[i]) + 1);
            }
        }
        fmt::print("Beads data file is written into: {}\n", path);
    }


    void Outputs::_write_cg_dump() const {
        std::string path = _inputs.tag + ".lammpstrj";
        std::fstream fid(path, std::fstream::out);

        for (size_t t=0; t<_dump.timesteps.size(); t++) {
            fmt::print(fid, "ITEM: TIMESTEP\n{}\n", _dump.timesteps[t]);
            fmt::print(fid, "ITEM: NUMBER OF ATOMS\n{}\n", _cg_data.beads.size());
            // Box information (triclinic): https://docs.lammps.org/Howto_triclinic.html
            fmt::print(fid, "ITEM: BOX BOUNDS xy xz yz pp pp pp\n");
            auto xy = _cg_dump.cg_ts[t].box(0, 1);
            auto xz = _cg_dump.cg_ts[t].box(0, 2);
            auto yz = _cg_dump.cg_ts[t].box(1, 2);
            auto xlo = 0.0;
            auto xhi = _cg_dump.cg_ts[t].box(0, 0) ;
            auto ylo = 0.0;
            auto yhi = _cg_dump.cg_ts[t].box(1, 1);
            auto zlo = 0.0;
            auto zhi = _cg_dump.cg_ts[t].box(2, 2);
            // Find the orthogonal bounding box which encloses the triclinic box
            auto xlo_bound = xlo + std::min(0.0, std::min(xy, std::min(xz, xy+xz)));
            auto xhi_bound = xhi + std::max(0.0, std::max(xy, std::max(xz, xy+xz)));
            auto ylo_bound = ylo + std::min(0.0, yz);
            auto yhi_bound = yhi + std::max(0.0, yz);
            auto zlo_bound = zlo;
            auto zhi_bound = zhi;
            // For a snapshot file for triclinic box the orthogonal box is output
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", xlo_bound, xhi_bound, xy);
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", ylo_bound, yhi_bound, xz);
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", zlo_bound, zhi_bound, yz);
            // Atoms' information
            if (_dump.coords_type == "unscaled") {
                fmt::print(fid, "ITEM: ATOMS id mol type x y z\n");
            }
            else if (_dump.coords_type == "scaled") {
                fmt::print(fid, "ITEM: ATOMS id mol type xs ys zs\n");
            }
            for (size_t i=0; i<_cg_data.beads.size(); i++) {
                auto bead = _cg_data.beads[i];
                fmt::print(fid, "{} {} {} ", bead.id+1, bead.chain+1, bead.type+1);
                auto coords = _cg_dump.cg_ts[t].coords[i];
                for (int j=0; j<coords.rows(); j++) {
                    fmt::print(fid, "{:9.6f} ", coords(j));
                }
                fmt::print(fid, "\n");
            }
        }
        fmt::print("Beads trajectory file is written into: {}\n", path);
    }

}


// Mapping matrix method
namespace MappingMatrix {

    // Constructor fo mapping matrix method
    Outputs::Outputs(const Inputs &inputs, const LMP_data &data, const LMP_dump &dump,
                     const Mapping &map, const Reorder &blocks, const CG_data &cg_data,
                     const CG_dump &cg_dump) : _inputs(inputs), _data(data), _dump(dump),
                      _mapping(map), _blocks(blocks), _cg_data(cg_data), _cg_dump(cg_dump) {
        fmt::print("\n################ Writing the outputs ####################\n");
        _write_cg_data();
        _write_cg_dump();
    }


    void Outputs::_write_cg_data() const {
        std::string path = _inputs.tag + ".lammps";
        std::fstream fid(path, std::fstream::out);
        // System properties
        fmt::print(fid, "LAMMPS data file generated by aa2cg.\n\n");
        fmt::print(fid, "{} atoms\n{} atom types\n"
                      , _cg_data.beads.size(), _cg_data.bead_types.size());
        // Bonds
        int num_bonds = 0;
        for (size_t i=0; i<_cg_data.bead_bonds.size(); i++) {
            for (size_t j=0; j<_cg_data.bead_bonds[i].size(); j++) {
                if ((int)i < _cg_data.bead_bonds[i][j]) {
                    num_bonds++;
                }
            }
        }
        fmt::print(fid, "{} bonds\n{} bond types\n"
                      , num_bonds, _cg_data.bead_bond_types.size());
        fmt::print(fid, "{} angles\n{} angle types\n"
                      , _cg_data.bead_angles.size(), _cg_data.bead_angle_types.size());
        fmt::print(fid, "{} dihedrals\n{} dihedral types\n"
                      , _cg_data.bead_torsions.size(), _cg_data.bead_torsion_types.size());
        if (_cg_data.bead_impropers.size() > 0) {
            fmt::print(fid, "{} impropers\n{} improper types\n"
                      , _cg_data.bead_impropers.size(), _cg_data.bead_improper_types.size());
        }
        fmt::print(fid, "\n");
        // Simulation box boundaries in x, y, and z direction
        auto xy = _data.box(0,1);
        auto xz = _data.box(0,2);
        auto yz = _data.box(1,2);
        auto xlo = 0.0;
        auto xhi = _data.box(0,0);
        auto ylo = 0.0;
        auto yhi = _data.box(1,1);
        auto zlo = 0.0;
        auto zhi = _data.box(2,2);
        // For data file contrary to the dump file the triclinic boundaries
        // themselves are written and not the bounding orthogonal box
        // https://docs.lammps.org/read_data.html
        fmt::print(fid, "{:6.3f} {:6.3f} xlo xhi\n", xlo, xhi);
        fmt::print(fid, "{:6.3f} {:6.3f} ylo yhi\n", ylo, yhi);
        fmt::print(fid, "{:6.3f} {:6.3f} zlo zhi\n", zlo, zhi);
        if (xy != 0.0 || xz != 0.0 || yz != 0.0) {
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f} xy xz yz\n", xy, xz, yz);
        }
        fmt::print(fid, "\n");
        // Masses
        fmt::print(fid, "Masses\n\n");
        for (auto const& [type, mass] : _cg_data.bead_types_masses) {
            fmt::print(fid, "{} {:6.3f}\n", type+1, mass);
        }
        if (_inputs.atom_style == "full") {
            // Atoms
            fmt::print(fid, "\nAtoms # full\n\n");
            int id = 0;
            for (int i=0; i<_blocks.num_blocks; i++) {
                for (auto coords : _cg_data.beads_coords[i]) {
                    for (int j=0; j<coords.rows(); j++) {
                        id++;
                        fmt::print(fid, "{} {} {} {:6.3f} "
                                      , id, i + 1, _cg_data.get_bead_type (j) + 1
                                      , _cg_data.beads[j].charge);
                        for (int k=0; k<coords.cols(); k++) {
                            fmt::print(fid, "{:6.3f} ", coords(j, k));
                        }
                        fmt::print(fid, "\n");
                    }
                }
            }
        }
        else if (_inputs.atom_style == "molecular") {
            // Atoms
            fmt::print(fid, "\nAtoms # molecular\n\n");
            int id = 0;
            for (int i=0; i<_blocks.num_blocks; i++) {
                for (auto coords : _cg_data.beads_coords[i]) {
                    for (int j=0; j<coords.rows(); j++) {
                        id++;
                        fmt::print(fid, "{} {} {} "
                                      , id, i + 1, _cg_data.get_bead_type (j) + 1);
                        for (int k=0; k<coords.cols(); k++) {
                            fmt::print(fid, "{:6.3f} ", coords(j, k));
                        }
                        fmt::print(fid, "\n");
                    }
                }
            }
        }
        // Bonds
        fmt::print(fid, "\nBonds\n\n");
        int bond_id = 0;
        for (size_t i=0; i<_cg_data.bead_bonds.size(); i++) {
            for (size_t j=0; j<_cg_data.bead_bonds[i].size(); j++) {
                if ((int)i < _cg_data.bead_bonds[i][j]) {
                    bond_id++;
                    fmt::print(fid, "{} {} {} {}\n", bond_id
                                  , _cg_data.get_bond_type(i, _cg_data.bead_bonds[i][j]) + 1
                                  , i + 1, _cg_data.bead_bonds[i][j] + 1);
                }
            }
        }
        // Angles
        fmt::print(fid, "\nAngles\n\n");
        for (size_t i=0; i<_cg_data.bead_angles.size(); i++) {
            fmt::print(fid, "{} {} {} {} {}\n"
                          , i + 1
                          , _cg_data.get_angle_type(std::get<0>(_cg_data.bead_angles[i])
                                              , std::get<1>(_cg_data.bead_angles[i])
                                              , std::get<2>(_cg_data.bead_angles[i]))
                          , std::get<0>(_cg_data.bead_angles[i]) + 1
                          , std::get<1>(_cg_data.bead_angles[i]) + 1
                          , std::get<2>(_cg_data.bead_angles[i]) + 1);
        }
        // Dihedrals
        fmt::print(fid, "\nDihedrals\n\n");
        for (size_t i=0; i<_cg_data.bead_torsions.size(); i++) {
            fmt::print(fid, "{} {} {} {} {} {}\n"
                          , i + 1
                          , _cg_data.get_torsion_type(std::get<0>(_cg_data.bead_torsions[i])
                                                , std::get<1>(_cg_data.bead_torsions[i])
                                                , std::get<2>(_cg_data.bead_torsions[i])
                                                , std::get<3>(_cg_data.bead_torsions[i]))
                          , std::get<0>(_cg_data.bead_torsions[i]) + 1
                          , std::get<1>(_cg_data.bead_torsions[i]) + 1
                          , std::get<2>(_cg_data.bead_torsions[i]) + 1
                          , std::get<3>(_cg_data.bead_torsions[i]) + 1);
        }
        // Impropers
        if (_cg_data.bead_impropers.size() > 0){
            fmt::print(fid, "\nImpropers\n\n");
            for (size_t i=0; i<_cg_data.bead_impropers.size(); i++) {
                fmt::print(fid, "{} {} {} {} {} {}\n"
                              , i + 1
                              , _cg_data.get_improper_type(std::get<0>(_cg_data.bead_impropers[i])
                                                    , std::get<1>(_cg_data.bead_impropers[i])
                                                    , std::get<2>(_cg_data.bead_impropers[i])
                                                    , std::get<3>(_cg_data.bead_impropers[i]))
                              , std::get<0>(_cg_data.bead_impropers[i]) + 1
                              , std::get<1>(_cg_data.bead_impropers[i]) + 1
                              , std::get<2>(_cg_data.bead_impropers[i]) + 1
                              , std::get<3>(_cg_data.bead_impropers[i]) + 1);
            }
        }
        fmt::print("Beads data file is written into: {}\n", path);
    }


    void Outputs::_write_cg_dump() const {
        std::string path = _inputs.tag + ".lammpstrj";
        std::fstream fid(path, std::fstream::out);

        for (size_t t=0; t<_dump.timesteps.size(); t++) {
            fmt::print(fid, "ITEM: TIMESTEP\n{}\n", _dump.timesteps[t]);
            fmt::print(fid, "ITEM: NUMBER OF ATOMS\n{}\n", _cg_data.beads.size());
            // Box information (triclinic): https://docs.lammps.org/Howto_triclinic.html
            fmt::print(fid, "ITEM: BOX BOUNDS xy xz yz pp pp pp\n");
            auto xy = _cg_dump.cg_ts[t].box(0, 1);
            auto xz = _cg_dump.cg_ts[t].box(0, 2);
            auto yz = _cg_dump.cg_ts[t].box(1, 2);
            auto xlo = 0.0;
            auto xhi = _cg_dump.cg_ts[t].box(0, 0) ;
            auto ylo = 0.0;
            auto yhi = _cg_dump.cg_ts[t].box(1, 1);
            auto zlo = 0.0;
            auto zhi = _cg_dump.cg_ts[t].box(2, 2);
            // Find the orthogonal bounding box which encloses the triclinic box
            auto xlo_bound = xlo + std::min(0.0, std::min(xy, std::min(xz, xy+xz)));
            auto xhi_bound = xhi + std::max(0.0, std::max(xy, std::max(xz, xy+xz)));
            auto ylo_bound = ylo + std::min(0.0, yz);
            auto yhi_bound = yhi + std::max(0.0, yz);
            auto zlo_bound = zlo;
            auto zhi_bound = zhi;
            // For a snapshot file for triclinic box the orthogonal box is output
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", xlo_bound, xhi_bound, xy);
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", ylo_bound, yhi_bound, xz);
            fmt::print(fid, "{:6.3f} {:6.3f} {:6.3f}\n", zlo_bound, zhi_bound, yz);
            // Atoms' information
            if (_dump.coords_type == "unscaled") {
                fmt::print(fid, "ITEM: ATOMS id mol type x y z\n");
            }
            else if (_dump.coords_type == "scaled") {
                fmt::print(fid, "ITEM: ATOMS id mol type xs ys zs\n");
            }
            int id = 0;
            for (size_t i=0; i<_blocks.block_atoms.size(); i++) {
                for (auto coords : _cg_dump.cg_ts[t].coords[i]) {
                    for (int j=0; j<coords.rows(); j++) {
                        id++;
                        fmt::print(fid, "{} {} {} ", id, i + 1, _cg_data.get_bead_type(j) + 1);
                        for (int k=0; k<coords.cols(); k++) {
                            fmt::print(fid, "{:9.6f} ", coords(j, k));
                        }
                        fmt::print(fid, "\n");
                    }
                }
            }
        }
        fmt::print("Beads trajectory file is written into: {}\n", path);
    }
}

